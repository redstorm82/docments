<!DOCTYPE html><html lang="zh-cmn-Hans"><head><meta charset="UTF-8"><title>Gulp开发教程（翻译） - w3ctech - 中国最大的前端技术社区</title><meta name=keywords content="前端, 前端开发, web前端, web前端开发, 前端开发工程师, 前端开发攻城师,设计, 开发, 前端资源, CSS, JavaScript, HTML, w3ctech, Web标准  "><meta name=description content="w3ctech是中国最大的前端技术社区。"><meta id=viewport name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"><meta name="apple-mobile-web-app-capable" content=yes><meta name="apple-mobile-web-app-status-bar-style" content=black><meta name="format-detection" content="telephone=no"><meta name="google-site-verification" content="Txx2nO_-cdhvFHc0w_oWSdYSOfy86nm6_jYfDXRj5lA"><link rel=icon type="image/png" sizes=16x16 href="http://img2.w3ctech.com/logo-16.png"><link rel=icon type="image/png" sizes=32x32 href="http://img2.w3ctech.com/logo-32.png"><link rel=icon type="image/png" sizes=48x48 href="http://img2.w3ctech.com/logo-48.png"><link rel=icon type="image/png" sizes=96x96 href="http://img2.w3ctech.com/logo-96.png"><link rel="apple-touch-icon-precomposed" sizes=96x96 href="http://img2.w3ctech.com/logo-96.png"><link rel="apple-touch-icon-precomposed" sizes=144x144 href="http://img2.w3ctech.com/logo-144.png"><link href="/resource/css/main.css?v=63ed5.css" rel=stylesheet><script src="//cdn.staticfile.org/jquery/1.11.1/jquery.min.js" ></script> <script>var _hmt=_hmt||[];(function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?d464a182f8055b18e3b7d861436bb35b";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)})()</script></head><body class=""><ul class="notes tip_box">  </ul> <header id=hd class=clearfix> <div class=hd_box> <h1 id=logo><a href="/">w3ctech</a></h1> <nav id=nav> <div class="nav-colse">关闭</div> <div class="nav-menu-stack"> <b class=srt>导航</b></div> <ul class=clearfix> <li><a href="/">首页</a> <li><a href="http://css.w3ctech.com">CSS Conf</a> <li><a href="/event">活动</a> <li><a href="http://code.w3ctech.com">Code</a> <li class=special><a href="/job">招聘</a> <li><a href="/thinkjs">thinkjs</a> <li><a href="/topic/all">所有文章</a> <li><a href="/topic/create">创建新主题</a>  <li class=login><a href="/user/sign_in" class=login_btn>登录</a> <li><a href="/user/sign_up" class=reg_btn>免费注册</a>  </ul></nav> <div class="search-box"> <form action="/index/search"> <input type=text placeholder="关键字" class="search-text" name=title> <button type=submit class="search-btn">搜索</button></form></div></div></header> <section id=bd> <div class=bd_box> <div class=topic_detail> <div class="topic_info clearfix"> <div class=topic_user><a href="/user/1260" class=latest><img width=50 height=50 src="http://img2.w3ctech.com/190c9591d4cd46391121303e451c273b.jpg" class="avatar latest" title="00_悦"></a></div> <h1>Gulp开发教程（翻译）</h1> <ul class=topic_category_list> <li><a href="/category/1" class=badge_category>JavaScript</a></ul> <ul class=meta> <li class=meta_professor title="00_悦"> <i class=icn_person></i> 00_悦 <li> <i class=icn_calendar></i> <time class=topic_date title="Tue Dec 23 2014 18:07:00 GMT+0800 (CST)">2014-12-23</time> <li> <i class=icn_views></i> 15300 访问 <li class=likes> <a href="/account/favorites?topic_id=134" data-id="134" class=likes_btn title="收藏"><i class=fa></i> <span class=likes_num>4</span></a> <li class=share> <span><i class=icn_share></i> 分享</span> <div class=share_list> <ul> <li><a href="http://service.t.sina.com.cn/share/share.php?title=Gulp开发教程（翻译）&url=http://w3ctech.com/topic/134&source=bookmark&appkey=3700213029&pic=&ralateUid=1887410462&language=zh_cn" title="分享至新浪微博" target=_blank class=sina_share>新浪微博</a> <li><a href="http://share.v.t.qq.com/index.php?c=share&a=index&f=q2&title=Gulp开发教程（翻译）&url=http://w3ctech.com/topic/134&appkey=801096309&assname=w3ctech&pic=" title="分享至腾讯微博" target=_blank class=tencent_share>腾讯微博</a></ul></div> <li class=share> <span><i class=weixin_share></i> 微信分享</span> <div class=share_list id="weixin-qrcode"></div>  </ul></div> <div class=callout> <h1 id="building-with-gulp">Building With Gulp</h1>
<p>===================</p>
<h5 id="-http-www-smashingmagazine-com-2014-06-11-building-with-gulp-"><a href="http://www.smashingmagazine.com/2014/06/11/building-with-gulp/">原文地址</a></h5>
<h5 id="-https-github-com-yeol-blog-blob-master-20140828_building_with_gulp-md-"><a href="https://github.com/yeol/blog/blob/master/20140828_building_with_gulp.md">翻译出处</a></h5>
<p>原创翻译，有不当的地方欢迎指出。转载请指明出处。谢谢！</p>
<hr>
<p>对网站资源进行优化，并使用不同浏览器测试并不是网站设计过程中最有意思的部分，但是这个过程中的很多重复的任务能够使用正确的工具自动完成，从而使效率大大提高，这是让很多开发者觉得有趣的地方。</p>
<p>Gulp是一个构建系统，它能通过自动执行常见任务，比如编译预处理CSS，压缩JavaScript和刷新浏览器，来改进网站开发的过程。通过本文，我们将知道如何使用Gulp来改变开发流程，从而使开发更加快速高效。</p>
<h3 id="what-is-gulp-">What Is Gulp?</h3>
<p><a href="http://gulpjs.com/">Gulp</a>是一个构建系统，开发者可以使用它在网站开发过程中自动执行常见任务。Gulp是基于Node.js构建的，因此Gulp源文件和你用来定义任务的Gulp文件都被写进了JavaScript（或者CoffeeScript）里。前端开发工程师还可以用自己熟悉的语言来编写任务去lint JavaScript和CSS、解析模板以及在文件变动时编译LESS文件（当然这些只是一小部分例子）。</p>
<p>Gulp本身虽然不能完成很多任务，但它有大量插件可用，开发者可以访问<a href="http://gulpjs.com/plugins/">插件页面</a>或者在npm搜索gulpplugin就能看到。例如，有些插件可以用来<a href="https://www.npmjs.org/package/gulp-jshint/">执行JSHint</a>、<a href="https://www.npmjs.org/package/gulp-coffee/">编译CoffeeScript</a>，<a href="http://npmjs.org/package/gulp-mocha">执行Mocha测试</a>，甚至<a href="http://npmjs.org/package/gulp-bump">更新版本号</a>。</p>
<p>对比其他构建工具，比如<a href="http://gruntjs.com/">Grunt</a>，以及最近流行的<a href="http://www.solitr.com/blog/2014/02/broccoli-first-release/">Broccoli</a>，我相信Gulp会更胜一筹（请看后面的”Why Gulp?”部分），同时我汇总了一个使用<a href="https://gist.github.com/callumacrae/9231589">Javascript编写的构建工具清单</a>，可供大家参考。</p>
<p>Gulp是一个可以<a href="https://github.com/gulpjs/gulp/">在GitHub上</a>找到的开源项目。</p>
<h3 id="installing-gulp">Installing Gulp</h3>
<p>安装Gulp的过程十分简单。首先，需要在全局安装Gulp包：</p>
<p><code>npm install -g gulp</code></p>
<p>然后，在项目里面安装Gulp：</p>
<p><code>npm install --save-dev gulp</code></p>
<h3 id="using-gulp">Using Gulp</h3>
<p>现在我们创建一个Gulp任务来压缩JavaScript文件。首先创建一个名为gulpfile.js的文件，这是定义Gulp任务的地方，它可以通过gulp命令来运行，接着把下面的代码放到gulpfile.js文件里面。</p>
<pre><code>var gulp = require(&#39;gulp&#39;),
   uglify = require(&#39;gulp-uglify&#39;);

gulp.task(&#39;minify&#39;, function () {
   gulp.src(&#39;js/app.js&#39;)
      .pipe(uglify())
      .pipe(gulp.dest(&#39;build&#39;))
});
</code></pre><p>然后在npm里面运行npm install -–save-dev gulp-uglify来安装gulp-uglify，最后通过运行gulp minify来执行任务。假设js目录下有个app.js文件，那么一个新的app.js将被创建在编译目录下，它包含了js/app.js的压缩内容。想一想，到底发生了什么？</p>
<p>我们只在gulpfile.js里做了一点事情。首先，我们加载gulp和gulp-uglify模块：</p>
<pre><code>var gulp = require(&#39;gulp&#39;),
    uglify = require(&#39;gulp-uglify&#39;);
</code></pre><p>然后，我们定义了一个叫minify的任务，它执行时会调用函数，这个函数会作为第二个参数：</p>
<pre><code>gulp.task(&#39;minify&#39;, function () {

});
</code></pre><p>最后，也是难点所在，我们需要定义任务应该做什么：</p>
<pre><code>gulp.src(&#39;js/app.js&#39;)
   .pipe(uglify())
   .pipe(gulp.dest(&#39;build&#39;))
</code></pre><p>如果你对数据流非常熟悉（其实大多数前端开发人员并不熟悉），上面所提供的代码对你来说就没有太大意义了。</p>
<h3 id="streams">STREAMS</h3>
<p>数据流能够通过一系列的小函数来传递数据，这些函数会对数据进行修改，然后把修改后的数据传递给下一个函数。</p>
<p>在上面的例子中，gulp.src()函数用字符串匹配一个文件或者文件的编号（被称为“glob”）,然后创建一个对象流来代表这些文件，接着传递给uglify()函数，它接受文件对象之后返回有新压缩源文件的文件对象，最后那些输出的文件被输入gulp.dest()函数，并保存下来。</p>
<p>整个数据流动过程如下图所示：
<img src="http://p1.qhimg.com/t01759cebd478ca1a35.png" alt=""></p>
<p>当只有一个任务的时候，函数并不会起太大的作用。然而，仔细思考下面的代码：</p>
<pre><code>gulp.task(&#39;js&#39;, function () {
   return gulp.src(&#39;js/*.js&#39;)
      .pipe(jshint())
      .pipe(jshint.reporter(&#39;default&#39;))
      .pipe(uglify())
      .pipe(concat(&#39;app.js&#39;))
      .pipe(gulp.dest(&#39;build&#39;));
});
</code></pre><p>在运行这段程序之前，你需要先安装gulp,gulp-jshint,gulp-uglify和gulp-concat。</p>
<p>这个任务会让所有的文件匹配js/*.js（比如js目录下的所有JavaScript文件），并且执行JSHint，然后打印输出结果，取消文件缩进，最后把他们合并起来，保存为build/app.js，整个过程如下图所示：
<img src="http://p0.qhimg.com/t01c6591bd2705a2ee7.png" alt=""></p>
<p>如果你对Grunt 足够熟悉，就会注意到，Gulp和Grunt的工作方式很不一样。Grunt不使用数据流，而是使用文件，对文件执行单个任务然后保存到新的文件中，每个任务都会重复执行所有进程，文件系统频繁的处理任务会导致Grunt的运行速度比Gulp慢。</p>
<p>如果想要获取更加全面的数据流知识，请查看“<a href="https://github.com/substack/stream-handbook">Stream Handbook</a>”.</p>
<h3 id="gulp-src-">GULP.SRC()</h3>
<p>gulp.src()方法输入一个glob(比如匹配一个或多个文件的字符串)或者glob数组，然后返回一个可以传递给插件的数据流。</p>
<p>Gulp使用<a href="https://github.com/isaacs/node-glob">node-glob</a>来从你指定的glob里面获取文件，这里列举下面的例子来阐述，方便大家理解：</p>
<ul>
<li>js/app.js   精确匹配文件</li>
<li>js/*.js     仅匹配js目录下的所有后缀为.js的文件</li>
<li>js/<em>*/</em>.js  匹配js目录及其子目录下所有后缀为.js的文件</li>
<li>!js/app.js  从匹配结果中排除js/app.js，这种方法在你想要匹配除了特殊文件之外的所有文件时非常管用</li>
<li>*.+(js|css) 匹配根目录下所有后缀为.js或者.css的文件</li>
</ul>
<p>此外，Gulp也有很多其他的特征，但并不常用。如果你想了解更多的特征，请查看<a href="https://github.com/isaacs/minimatch">Minimatch</a>文档。</p>
<p>js目录下包含了压缩和未压缩的JavaScript文件，现在我们想要创建一个任务来压缩还没有被压缩的文件，我们需要先匹配目录下所有的JavaScript文件，然后排除后缀为.min.js的文件:</p>
<p><code>gulp.src([&#39;js/**/*.js&#39;, &#39;!js/**/*.min.js&#39;])</code></p>
<h3 id="defining-tasks">DEFINING TASKS</h3>
<p>gulp.task()函数通常会被用来定义任务。当你定义一个简单的任务时，需要传入任务名字和执行函数两个属性。</p>
<pre><code>gulp.task(&#39;greet&#39;, function () {
   console.log(&#39;Hello world!&#39;);
});
</code></pre><p>执行gulp greet的结果就是在控制台上打印出“Hello world”.</p>
<p>一个任务有时也可以是一系列任务。假设要定义一个任务build来执行css、js、imgs这三个任务，我们可以通过指定一个任务数组而不是函数来完成。</p>
<p><code>gulp.task(&#39;build&#39;, [&#39;css&#39;, &#39;js&#39;, &#39;imgs&#39;]);</code></p>
<p>这些任务不是同时进行的，所以你不能认为在js任务开始的时候css任务已经结束了，也可能还没有结束。为了确保一个任务在另一个任务执行前已经结束，可以将函数和任务数组结合起来指定其依赖关系。例如，定义一个css任务，在执行前需要检查greet任务是否已经执行完毕，这样做就是可行的:</p>
<pre><code>gulp.task(&#39;css&#39;, [&#39;greet&#39;], function () {
   // Deal with CSS here
});
</code></pre><p>现在，当执行css任务时，Gulp会先执行greet任务，然后在它结束后再调用你定义的函数。</p>
<h3 id="default-tasks">DEFAULT TASKS</h3>
<p>你可以定义一个在gulp开始运行时候默认执行的任务，并将这个任务命名为“default”：</p>
<pre><code>gulp.task(&#39;default&#39;, function () {
   // Your default task
});
</code></pre><h3 id="plugins">PLUGINS</h3>
<p>Gulp上有超过600种插件供你选择，你可以在<a href="http://gulpjs.com/plugins/">插件页面</a>或者npm上搜索gulpplugin来浏览插件列表。有些拥有“gulpfriendly”标签的插件，他们不能算插件，但是能在Gulp上正常运行。
需要注意的是，当直接在npm里搜索时，你无法知道某一插件是否在黑名单上（你需要滚动到插件页面底部才能看到）。</p>
<p>大多数插件的使用都很方便，它们都配有详细的文档，而且调用方法也相同（通过传递文件对象流给它），它们通常会对这些文件进行修改（但是有一些插件例外，比如validators），最后返回新的文件给下一个插件。</p>
<p>让我们用前面的js任务来详细说明一下：</p>
<pre><code>var gulp = require(&#39;gulp&#39;),
    jshint = require(&#39;gulp-jshint&#39;),
    uglify = require(&#39;gulp-uglify&#39;),
    concat = require(&#39;gulp-concat&#39;);

gulp.task(&#39;js&#39;, function () {
   return gulp.src(&#39;js/*.js&#39;)
      .pipe(jshint())
      .pipe(jshint.reporter(&#39;default&#39;))
      .pipe(uglify())
      .pipe(concat(&#39;app.js&#39;))
      .pipe(gulp.dest(&#39;build&#39;));
});
</code></pre><p>这里使用了三个插件，<a href="https://github.com/wearefractal/gulp-jshint">gulp-jshint</a>,<a href="https://github.com/terinjokes/gulp-uglify">gulp-uglify</a>和<a href="https://github.com/wearefractal/gulp-concat">gulp-concat</a>。开发者可以参考插件的README文档，插件有很多配置选项，而且给定的初始值通常能满足需求。细心的读者可能会发现，程序中JSHint插件执行了2次，这是因为第一次执行JSHint只是给文件对象附加了jshint属性，并没有输出。你可以自己读取jshint的属性或者传递给默认的JSHint的接收函数或者其他的接收函数,比如<a href="https://github.com/sindresorhus/jshint-stylish">jshint-stylish</a>.</p>
<p>其他两个插件的作用很清楚：uglify()函数压缩代码，concat(‘app.js’)函数将所有文件合并到一个叫app.js的文件中。</p>
<h3 id="gulp-load-plugins">GULP-LOAD-PLUGINS</h3>
<p>我发现gulp-load-plugin模块十分有用，它能够自动地从package.json中加载任意Gulp插件然后把它们附加到一个对象上。它的基本用法如下所示：</p>
<pre><code>var gulpLoadPlugins = require(&#39;gulp-load-plugins&#39;),
    plugins = gulpLoadPlugins();
</code></pre><p>你可以把所有代码写到一行，但是我并不推荐这样做。</p>
<p>在执行那些代码之后，插件对象就已经包含了插件，并使用“驼峰式”的方式进行命名（例如，gulp-ruby-sass将被加载成plugins.rubySass），这样就可以很方便地使用了。例如，前面的js任务简化为如下：</p>
<pre><code>var gulp = require(&#39;gulp&#39;),
    gulpLoadPlugins = require(&#39;gulp-load-plugins&#39;),
    plugins = gulpLoadPlugins();

gulp.task(&#39;js&#39;, function () {
   return gulp.src(&#39;js/*.js&#39;)
      .pipe(plugins.jshint())
      .pipe(plugins.jshint.reporter(&#39;default&#39;))
      .pipe(plugins.uglify())
      .pipe(plugins.concat(&#39;app.js&#39;))
      .pipe(gulp.dest(&#39;build&#39;));
});
</code></pre><p>假设package.json文件如下面所示：</p>
<pre><code>{
   &quot;devDependencies&quot;: {
      &quot;gulp-concat&quot;: &quot;~2.2.0&quot;,
      &quot;gulp-uglify&quot;: &quot;~0.2.1&quot;,
      &quot;gulp-jshint&quot;: &quot;~1.5.1&quot;,
      &quot;gulp&quot;: &quot;~3.5.6&quot;
   }
}
</code></pre><p>这个例子虽然已经够短了，但是使用更长更复杂的Gulp文件会把它们简化成一两行代码。</p>
<p>三月初发布的Gulp-load-plugins0.4.0版本添加了延迟加载功能，提高了插件的性能，因为插件在使用的时候才会被加载进来，你不用担心package.json里未被使用的插件影响性能（但是你需要把他们清理掉）。换句话说，如果你在执行任务时只需要两个插件，那么其他不相关的插件就不会被加载。</p>
<h3 id="watching-files">WATCHING FILES</h3>
<p>Gulp可以监听文件的修改动态，然后在文件被改动的时候执行一个或多个任务。这个特性十分有用（对我来说，这可能是Gulp中最有用的一个功能）。你可以保存LESS文件，接着Gulp会自动把它转换为CSS文件并更新浏览器。</p>
<p>使用gulp.watch()方法可以监听文件，它接受一个glob或者glob数组（和gulp.src()一样）以及一个任务数组来执行回调。</p>
<p>让我们看看下面，build任务可以将模板转换成html格式，然后我们希望定义一个watch任务来监听模板文件的变化，并将这些模板转换成html格式。watch函数的使用方法如下所示：</p>
<pre><code>gulp.task(&#39;watch&#39;, function () {
   gulp.watch(&#39;templates/*.tmpl.html&#39;, [&#39;build&#39;]);
});
</code></pre><p>现在，当改变一个模板文件时，build任务会被执行并生成HTML文件，也可以给watch函数一个回调函数，而不是一个任务数组。在这个示例中，回调函数有一个包含触发回调函数信息的event对象：</p>
<pre><code>gulp.watch(&#39;templates/*.tmpl.html&#39;, function (event) {
   console.log(&#39;Event type: &#39; + event.type); // added, changed, or deleted
   console.log(&#39;Event path: &#39; + event.path); // The path of the modified file
});
</code></pre><p>Gulp.watch()的另一个非常好的特性是返回我们熟知的watcher。利用watcher来监听额外的事件或者向watch中添加文件。例如，在执行一系列任务和调用一个函数时，你就可以在返回的watcher中添加监听change事件:</p>
<pre><code>var watcher = gulp.watch(&#39;templates/*.tmpl.html&#39;, [&#39;build&#39;]);
watcher.on(&#39;change&#39;, function (event) {
   console.log(&#39;Event type: &#39; + event.type); // added, changed, or deleted
   console.log(&#39;Event path: &#39; + event.path); // The path of the modified file
});
</code></pre><p>除了change事件，还可以监听很多其他的事件:</p>
<ul>
<li>end      在watcher结束时触发（这意味着，在文件改变的时候，任务或者回调不会执行）</li>
<li>error    在出现error时触发</li>
<li>ready    在文件被找到并正被监听时触发</li>
<li>nomatch  在glob没有匹配到任何文件时触发</li>
</ul>
<p>Watcher对象也包含了一些可以调用的方法：</p>
<ul>
<li>watcher.end()      停止watcher（以便停止执行后面的任务或者回调函数）</li>
<li>watcher.files()    返回watcher监听的文件列表</li>
<li>watcher.add(glob)  将与指定glob相匹配的文件添加到watcher（也接受可选的回调当第二个参数）</li>
<li>watcher.remove(filepath) 从watcher中移除个别文件</li>
</ul>
<h3 id="reloading-changes-in-the-browser">Reloading Changes In The Browser</h3>
<p>当一个文件被修改或者Gulp任务被执行时可以用Gulp来加载或者更新网页。LiveReload和BrowserSync插件就可以用来实现在游览器中加载更新的内容。</p>
<h4 id="livereload">LIVERELOAD</h4>
<p><a href="http://livereload.com/">LiveReload</a>结合了浏览器扩展（包括<a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei">Chrome extension</a>），在发现文件被修改时会实时更新网页。它可以和<a href="https://www.npmjs.org/package/gulp-watch">gulp-watch</a>插件或者前面描述的gulp-watch()函数一起使用。下面有一个<a href="https://github.com/vohof/gulp-livereload">gulp-livereload</a>仓库中的README文件提到的例子:</p>
<pre><code>var gulp = require(&#39;gulp&#39;),
    less = require(&#39;gulp-less&#39;),
    livereload = require(&#39;gulp-livereload&#39;),
    watch = require(&#39;gulp-watch&#39;);

gulp.task(&#39;less&#39;, function() {
   gulp.src(&#39;less/*.less&#39;)
      .pipe(watch())
      .pipe(less())
      .pipe(gulp.dest(&#39;css&#39;))
      .pipe(livereload());
});
</code></pre><p>这会监听到所有与less/*.less相匹配的文件的变化。一旦监测到变化，就会生成css并保存，然后重新加载网页.</p>
<h4 id="browsersync">BROWSERSYNC</h4>
<p><a href="http://browsersync.io/">BroserSync</a>在浏览器中展示变化的功能与LiveReload非常相似，但是它有更多的功能。</p>
<p>当你改变代码的时候，BrowserSync会重新加载页面，或者如果是css文件，会直接添加进css中，页面并不需要再次刷新。这项功能在网站是禁止刷新的时候是很有用的。假设你正在开发单页应用的第4页，刷新页面就会导致你回到开始页。使用LiveReload的话，你就需要在每次改变代码之后还需要点击四次，而当你修改CSS时，插入一些变化时，BrowserSync会直接将需要修改的地方添加进CSS，就不用再点击回退。</p>
<p><img src="http://p7.qhimg.com/t01b21adb0b23364a0c.gif" alt=""></p>
<p>BrowserSync提供了一种在多个浏览器里测试网页的很好方式<a href="http://p7.qhimg.com/t01b21adb0b23364a0c.gif">（查看大图）</a>。</p>
<p>BrowserSync也可以在不同浏览器之间同步点击翻页、表单操作、滚动位置。你可以在电脑和iPhone上打开不同的浏览器然后进行操作。所有设备上的链接将会随之变化，当你向下滚动页面时，所有设备上页面都会向下滚动（通常还很流畅！）。当你在表单中输入文本时，每个窗口都会有输入。当你不想要这种行为时，也可以把这个功能关闭。</p>
<p><img src="http://p4.qhimg.com/t011034e5a90ce13015.gif" alt=""></p>
<p>BrowserSync不需要使用浏览器插件，因为它本身就可以给你提供文件。<a href="http://p4.qhimg.com/t011034e5a90ce13015.gif">（查看大图）</a></p>
<p>BrowserSync不需要使用浏览器插件，因为它本身就可以为你提供文件服务（如果文件是动态的，则为他们提供代理服务）和用来开启浏览器和服务器之间的socket的脚本服务。到目前为止这个功能的使用都十分顺畅。</p>
<p>实际上BrowserSync对于Gulp并不算一种插件，因为BrowserSync并不像一个插件一样操作文件。然而，<a href="https://www.npmjs.org/package/browser-sync">npm上的BrowserSync模块</a>能在Gulp上被直接调用。</p>
<p>首先，需要通过npm安装一下：</p>
<p><code>npm install --save-dev browser-sync</code></p>
<p>然后gulpfile.js会启动BrowserSync并监听文件：</p>
<pre><code>var gulp = require(&#39;gulp&#39;),
    browserSync = require(&#39;browser-sync&#39;);

gulp.task(&#39;browser-sync&#39;, function () {
   var files = [
      &#39;app/**/*.html&#39;,
      &#39;app/assets/css/**/*.css&#39;,
      &#39;app/assets/imgs/**/*.png&#39;,
      &#39;app/assets/js/**/*.js&#39;
   ];

   browserSync.init(files, {
      server: {
         baseDir: &#39;./app&#39;
      }
   });
});
</code></pre><p>执行gulp browser-sync后会监听匹配文件的变化，同时为app目录提供文件服务。</p>
<p>此外BrowserSync的开发者还写了很多关于<a href="https://github.com/shakyShane/gulp-browser-sync">BrowserSync+Gulp</a>仓库的其他用途。</p>
<h3 id="why-gulp-">Why Gulp?</h3>
<p>前面提到过，Gulp是<a href="https://gist.github.com/callumacrae/9231589">为数不多</a>的使用JavaScript开发的构建工具之一，也有其他不是用JavaScript开发的构建工具，比如Rake，那么我们为什么要选择Gulp呢?</p>
<p>目前最流行的两种使用JavaScript开发的构建工具是Grunt和Gulp。Grunt在<a href="http://www.smashingmagazine.com/2013/10/29/get-up-running-grunt/">2013年非常流行</a>，因为它彻底改变了许多人开发网站的方式，它有上千种插件可供用户使用，从linting、压缩、合并代码到使用Bower安装程序包,启动Express服务都能办到。这些和Gulp的很不一样，Gulp只有执行单个小任务来处理文件的插件，因为任务都是JavaScript（和Grunt使用的大型对象不同），根本不需要插件，你只需用传统方法启动一个Express服务就可以了。</p>
<p>Grunt任务拥有大量的配置，会引用大量你实际上并不需要的对象属性，但是Gulp里同样的任务也许只有几行。让我们看个简单的Gruntfile.js，它规定一个将LESS转换为CSS的任务，然后执行<a href="https://github.com/ai/autoprefixer">Autoprefixer</a>:</p>
<pre><code>grunt.initConfig({
   less: {
      development: {
         files: {
            &quot;build/tmp/app.css&quot;: &quot;assets/app.less&quot;
         }
      }
   },

   autoprefixer: {
      options: {
         browsers: [&#39;last 2 version&#39;, &#39;ie 8&#39;, &#39;ie 9&#39;]
      },
      multiple_files: {
         expand: true,
         flatten: true,
         src: &#39;build/tmp/app.css&#39;,
         dest: &#39;build/&#39;
      }
   }
});

grunt.loadNpmTasks(&#39;grunt-contrib-less&#39;);
grunt.loadNpmTasks(&#39;grunt-autoprefixer&#39;);

grunt.registerTask(&#39;css&#39;, [&#39;less&#39;, &#39;autoprefixer&#39;]);
</code></pre><p>与Gulpfile.js文件进行对比，它们执行的任务相同：</p>
<pre><code>var gulp = require(&#39;gulp&#39;),
   less = require(&#39;gulp-less&#39;),
   autoprefix = require(&#39;gulp-autoprefixer&#39;);

gulp.task(&#39;css&#39;, function () {
   gulp.src(&#39;assets/app.less&#39;)
      .pipe(less())
      .pipe(autoprefix(&#39;last 2 version&#39;, &#39;ie 8&#39;, &#39;ie 9&#39;))
      .pipe(gulp.dest(&#39;build&#39;));
});
</code></pre><p>因为Grunt比Gulp更加频繁地操作文件系统，所以使用数据流的Gulp总是比Grunt快。对于一个小的LESS文件，gulpfile.js通常需要6ms，而gruntfile.js则需要大概50ms——慢8倍多。这只是个简单的例子，对于长的文件，这个数字会增加得更显著。</p>
 <div id="wx-qrcode" class=wx_qrcode_box><img src="http://img2.w3ctech.com/qrcode_for_gh_229345f1b408_258.jpg" alt="w3ctech微信" class=weixin_qrcode><p>扫码关注w3ctech微信公众号</p></div></div>  <div class=disclaimer> <i class="fa fa-frown-o"></i> <p> 只有w3ctech成员才能发表和回复。 <br> 请 <a href="/user/sign_in">登录</a> 或者 <a href="/user/sign_up">注册</a> 后发表或回复！ </p></div>  </div> <div class=topic_comment_hd> <h2>共收到4条回复</h2></div> <div class=topic_comment> <div class=topic_answers_content> <ul>   <li class=clearfix id="comment-594"> <div class=topic_user><img width=50 height=50 src="http://img2.w3ctech.com/df939321fa6638446fa1cc9b35d90f3a.jpg"></div> <div class=comment_content> <p class=byline><a href="/user/2966">AlexZou</a> <span class=time>2014-12-02 12:31</span></p> <div class=comment_content_text> <p>npm install –save-dev gulp-uglify<br>save前面少了一个横杠
应该是npm install –-save-dev gulp-uglify</p>
 </div> <div class=topic_comment_actions> <span class=add_comment data-nickname="AlexZou">回复此楼 <i class="fa fa-share"></i></span></div></div>  <li class=clearfix id="comment-684"> <div class=topic_user><img width=50 height=50 src="http://img2.w3ctech.com/190c9591d4cd46391121303e451c273b.jpg"></div> <div class=comment_content> <p class=byline><a href="/user/1260">00_悦</a> <span class=time>2014-12-23 18:06</span></p> <div class=comment_content_text> <p>谢谢、已修正。</p>
 </div> <div class=topic_comment_actions> <span class=add_comment data-nickname="00_悦">回复此楼 <i class="fa fa-share"></i></span></div></div>  <li class=clearfix id="comment-1044"> <div class=topic_user><img width=50 height=50 src="http://img2.w3ctech.com/59a9b678e663339fbdee5e16b28f4018.jpg"></div> <div class=comment_content> <p class=byline><a href="/user/2594">pdsbfqq</a> <span class=time>2015-04-20 09:48</span></p> <div class=comment_content_text> <p>请问，你这边用的什么GIF截图工具，方便告知下吗？谢谢！</p>
 </div> <div class=topic_comment_actions> <span class=add_comment data-nickname="pdsbfqq">回复此楼 <i class="fa fa-share"></i></span></div></div>  <li class=clearfix id="comment-1381"> <div class=topic_user><img width=50 height=50 src="http://img2.w3ctech.com/1845e6ed6e658a70d54cdddbc1447bd3.jpg"></div> <div class=comment_content> <p class=byline><a href="/user/5679">mqliutie</a> <span class=time>2015-06-19 14:06</span></p> <div class=comment_content_text> <p>这里应该是原文你的一个问题吧
在  <code>LIVERELOAD</code>   这块里面 </p>
<pre><code class="lang-JavaScript">var gulp = require(&#39;gulp&#39;),
    less = require(&#39;gulp-less&#39;),
    livereload = require(&#39;gulp-livereload&#39;),
    watch = require(&#39;gulp-watch&#39;);

gulp.task(&#39;less&#39;, function() {
   gulp.src(&#39;less/*.less&#39;)
      .pipe(watch())
      //  这里面的watch() 需要参数的   在这里应该是  .pipe(watch(&quot;less/*.less&quot;))
      .pipe(less())
      .pipe(gulp.dest(&#39;css&#39;))
      .pipe(livereload());
});
</code></pre>
 </div> <div class=topic_comment_actions> <span class=add_comment data-nickname="mqliutie">回复此楼 <i class="fa fa-share"></i></span></div></div>   </ul></div>   <div class=disclaimer> <i class="fa fa-frown-o"></i> <p> 只有w3ctech成员才能发表和回复。 <br> 请 <a href="/user/sign_in">登录</a> 或者 <a href="/user/sign_up">注册</a> 后发表或回复！ </p></div>  </div></div> </section><script src="http://img2.w3ctech.com/jquery.qrcode.min.js" ></script><script>var qrcodeUrl = "http://www.w3ctech.com/topic/" + 134;
    $("#weixin-qrcode").qrcode({
        "width": 100,
        "height": 100,
        "text": qrcodeUrl
});</script><footer id=ft> <div class=ft_box> <div class="footer clearfix"> <div class=footer_link> <ul> <li>赞助商     <li><a href="http://meituan.com">美团网</a>          <li><a href="http://www.75team.com">奇舞团</a>    <li><a href="http://www.sina.com.cn">新浪</a>    <li><a href="http://www.ctrip.com">携程网</a>    <li><a href="http://tech.163.com">网易科技</a>    <li><a href="http://www.qq.com">腾讯</a>    <li><a href="http://www.thenetcircle.com/">The NetCircle</a>    <li><a href="http://www.taobao.com/">淘宝</a>    <li><a href="http://www.xunlei.com/">迅雷网络</a>    <li><a href="http://www.360.cn/">360</a>    <li><a href="http://www.dangdang.com/">当当网</a>                <li><a href="http://ued.yhd.com">1号店</a>      <li><a href="http://fex.baidu.com">百度FEX</a>          <li><a href="http://www.microsoft.com/china/ard/accelerator.aspx">微软云加速器</a>                <li><a href="https://gitcafe.com/">GitCafe</a>      <li><a href="http://qqfe.org/">WFE-腾讯网前端团队</a>     </ul><ul> <li>合作伙伴           <li><a href="http://www.infoq.com/cn/">InfoQ</a>                        <li><a href="http://www.blueidea.com">蓝色理想</a>    <li><a href="http://www.chinaw3c.org">W3C中国总部</a>    <li><a href="http://www.webrebuild.org">WebRebuild</a>    <li><a href="http://www.lamper.cn/">lamper</a>    <li><a href="http://www.w3schools.com/cn/">W3Schools中文站</a>    <li><a href="http://w3help.org/">W3Help</a>              <li><a href="http://mozilla.com.cn/">火狐社区</a>            <li><a href="http://www.teambition.com">Teambition</a>               </ul><ul> <li>友情链接   <li><a href="http://www.zaoduke.net">前端De早读课</a>      <li><a href="http://www.html5china.com/">HTML5中文网</a>    <li><a href="http://www.html5dw.com/">HTML5梦工场</a>                                        <li><a href="http://www.qianduan.net/">前端观察</a>      <li><a href="http://simple-is-better.com/">python4cn</a>    <li><a href="http://www.thinksaas.cn/">ThinkSAAS</a>        <li><a href="http://www.AlloyTeam.com/">腾讯Web前端Alloy团队</a>    <li><a href="http://html5.360.cn/">HTML5基地</a>    <li><a href="http://cn.cocos2d-x.org/">Cocos引擎中文官网</a>      <li><a href="http://www.shiyanlou.com">实验楼IT在线教育</a>    <li><a href="http://www.w3cplus.com">W3cplus</a>      <li><a href="http://www.51h5.com/">火舞游戏</a>      <li><a href="http://ionichina.com">ionichina 社区</a>   </ul></div> <div class=footer_about> <p> w3ctech创立于2009年10月，是中国最大的前端技术社区。 <span><a href="/about">了解更多</a></span> <img src="http://img2.w3ctech.com/qrcode_for_gh_229345f1b408_258.jpg" alt="w3ctech微信" width=150 class=weixin_qrcode> </p></div></div> <div class=foot_sponsor> <a href="https://portal.qiniu.com/signup?code=3lid1lelqhemm"><img src="http://img2.w3ctech.com/logo_QINIU.png" alt="七牛云存储"><em>由七牛提供存储</em></a> <a href="http://www.ucloud.cn/"><img src="http://img2.w3ctech.com/logo_Ucloud.png" alt=UCloud><em>由UCloud提供云主机</em></a> <a href="http://thinkjs.org"><img src="http://img2.w3ctech.com/logo_ThinkJs.png" alt=thinkjs><em>由thinkjs强力驱动</em></a></div> <div class=footer_sub> <p class=footer_copyright>&copy; 2009 - 2015 w3ctech.</p> <p><a href="http://www.miitbeian.gov.cn/">京ICP备14023423号-2</a></p> <div class=list_social> <a href="http://weibo.com/w3ctech" class=social_weibo>微博</a> <a href="/" class=social_weixin>微信</a></div></div></div></footer> <script src="/resource/js/w3ctech.js?v=7cf2e.js" ></script> <script src="http://res.wx.qq.com/open/js/jweixin-1.0.0.js" ></script> <script>$(document).ready(function(){$.when($(".callout pre").addClass(" prettyprint"),$(".comment_content_text pre").addClass(" prettyprint")).then(function(){prettyPrint()})});var locationLink=location.href;document.write(unescape("%3Cscript src='http://api.wechat.w3ctech.com/js_sdk?url="+locationLink+"' type='text/javascript'%3E%3C/script%3E"))</script> <script>var shareMessage={title:"w3ctech",desc:"w3ctech\u662f\u4e2d\u56fd\u6700\u5927\u7684\u524d\u7aef\u6280\u672f\u793e\u533a\u3002",link:location.href,imgUrl:"http://www.w3ctech.com/resource/img/w3ctech-120-logo.jpg",type:"link",dataUrl:"",success:function(){},cancel:function(){}};wx.ready(function(){shareMessage.title=document.title,wx.onMenuShareTimeline(shareMessage),wx.onMenuShareAppMessage(shareMessage)})</script></body></html>